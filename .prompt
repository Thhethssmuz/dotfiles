#!/bin/bash

#
# Helpers
#

function __promptline_wrap {
  [[ -n "$1" ]] || return 1
  printf "%s" "${2}${1}${3}"
}
function __promptline_ps1_print {
  if [ "$is_empty" -eq 1 ]; then
    prefix="$empty_prefix"
  fi
  if __promptline_wrap "$1" "$prefix" "$suffix"; then
    is_empty=0
  fi
}


#
# Segments
#

function __promptline_last_exit_code {
  [[ $last_exit_code -gt 0 ]] || return
  printf "%s" "$last_exit_code"
}

function __promptline_host {
  if [ -n "${SSH_CLIENT}" ]; then
    printf "%s" \\h;
  elif [[ "$(hostname)" = *-vm ]]; then
    printf "%s" \\h;
  fi
}

function __promptline_cwd {
  local dir_limit="3"
  local truncation="⋯"
  local part_count=0
  local formatted_cwd=""
  local dir_sep="  "
  local tilde="~"

  local cwd="${PWD/#$HOME/$tilde}"

  local git_root_dir
  local git_match=1
  local git_matched=0
  if [[ $(git rev-parse --is-inside-work-tree 2>/dev/null) == true ]]; then
    git_root_dir=$(git rev-parse --show-toplevel)
    git_root_dir=${git_root_dir/$HOME/\~}
    git_match=0
  fi

  while true; do
    local part="${cwd##*/}"
    local last
    [ "$part" == "" ] && part="/"
    [ "$cwd" == "$part" ] && last=1 || last=0

    if [ $git_match ] && [ "$cwd" == "$git_root_dir" ]; then
      part=$(__promptline_wrap "$part" "${bold}${git_fg}" "${cwd_fg}${reset_bold}")
      git_match=1
      git_matched=1
    fi

    case "${git_match}${git_matched}$((part_count >= dir_limit))$((part_count == dir_limit))${last}" in
      ??000) formatted_cwd="${dir_sep}${part}${formatted_cwd}" ;;
      00100) ;;
      00110) formatted_cwd="${dir_sep}${truncation}${formatted_cwd}" ;;
      1???1) formatted_cwd="${part}${formatted_cwd}" ; break ;;
      10110) formatted_cwd="${truncation}${formatted_cwd}"; break ;;
      111?0) formatted_cwd="${truncation}${dir_sep}${part}${formatted_cwd}"; break ;;
      *)     break ;; # this shouldn't happen, but just in case; don't go into an infinite loop
    esac

    cwd="${cwd%/*}"
    [ "$cwd" == "" ] && cwd="/"
    part_count=$((part_count+1))
    git_matched=0
  done

  printf "%s" "$formatted_cwd"
}

function __promptline_git {
  [[ $(git rev-parse --is-inside-work-tree 2>/dev/null) == true ]] || return

  local branch
  branch=$( { git symbolic-ref --quiet HEAD || git rev-parse --short HEAD; } 2>/dev/null )
  branch=${branch##*/}

  local branch_symbol=" "
  local added_symbol="●"
  local unmerged_symbol="✗"
  local modified_symbol="+"
  local clean_symbol="✔"
  local has_untracked_files_symbol="…"
  local ahead_symbol="↑"
  local behind_symbol="↓"

  local unmerged_count=0
  local modified_count=0
  local has_untracked_files=0
  local added_count=0
  local is_clean=0

  # shellcheck disable=SC2046
  set -- $(git rev-list --left-right --count "@{upstream}...HEAD" 2>/dev/null)
  local behind_count=$1
  local ahead_count=$2

  # Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), changed (T), Unmerged (U), Unknown (X), Broken (B)
  while read -r line; do
    case "$line" in
      M*) modified_count=$(( modified_count + 1 )) ;;
      U*) unmerged_count=$(( unmerged_count + 1 )) ;;
    esac
  done < <(git diff --name-status)

  while read -r line; do
    case "$line" in
      *) added_count=$(( added_count + 1 )) ;;
    esac
  done < <(git diff --name-status --cached)

  if [ -n "$(git ls-files --others --exclude-standard)" ]; then
    has_untracked_files=1
  fi

  if [ $(( unmerged_count + modified_count + has_untracked_files + added_count )) -eq 0 ]; then
    is_clean=1
  fi

  printf "%s" "${branch_symbol}${bold}${branch:-unknown}${reset_bold}${space}"

  local leading_whitespace=""
  [[ $ahead_count -gt 0 ]]         && { printf "%s" "${leading_whitespace}${ahead_symbol}${ahead_count}"; leading_whitespace=" "; }
  [[ $behind_count -gt 0 ]]        && { printf "%s" "${leading_whitespace}${behind_symbol}${behind_count}"; leading_whitespace=" "; }
  [[ $modified_count -gt 0 ]]      && { printf "%s" "${leading_whitespace}${modified_symbol}${modified_count}"; leading_whitespace=" "; }
  [[ $unmerged_count -gt 0 ]]      && { printf "%s" "${leading_whitespace}${unmerged_symbol}${unmerged_count}"; leading_whitespace=" "; }
  [[ $added_count -gt 0 ]]         && { printf "%s" "${leading_whitespace}${added_symbol}${added_count}"; leading_whitespace=" "; }
  [[ $has_untracked_files -gt 0 ]] && { printf "%s" "${leading_whitespace}${has_untracked_files_symbol}"; leading_whitespace=" "; }
  [[ $is_clean -gt 0 ]]            && { printf "%s" "${leading_whitespace}${clean_symbol}"; leading_whitespace=" "; }

  return $is_clean
}


#
# Main
#

function __promptline_ps1 {
  local prefix
  local empty_prefix
  local suffix
  local is_empty=1

  local warn_content host_content cwd_content git_content

  if git_content="$(__promptline_git)"; then
    git_fg="$git_dirty_fg"
  else
    git_fg="$git_clean_fg"
  fi
  cwd_content="$(__promptline_cwd)"
  host_content="$(__promptline_host)"
  warn_content="$(__promptline_last_exit_code)"


  # warn section
  empty_prefix="${warn_fg}${warn_bg}${space}"
  prefix="${warn_bg}${sep}${warn_fg}${warn_bg}${space}"
  suffix="${space}${warn_sep_fg}"
  __promptline_ps1_print "$warn_content"

  # host section
  empty_prefix="${host_fg}${host_bg}${space}"
  prefix="${host_bg}${sep}${host_fg}${host_bg}${space}"
  suffix="${space}${host_sep_fg}"
  __promptline_ps1_print "$host_content"

  # cwd section
  empty_prefix="${cwd_fg}${space}"
  prefix="${reset_bg}${sep}${cwd_fg}${space}"
  suffix=""
  __promptline_ps1_print "$cwd_content"

  # git section
  empty_prefix="${git_fg}${space}"
  prefix="${git_fg}${space}"
  suffix=""
  __promptline_ps1_print "$git_content"

  # close sections
  printf "%s" "${reset}\\n${alt_sep}${space}"
}

function __promptline {

  # needs to be done first other wise the exit code will be masked by other operations
  local last_exit_code="$?"

  # ansi colour code wrappers
  local esc=$'[' end_esc=m
  local noprint='\[' end_noprint='\]'
  local wrap="$noprint$esc" end_wrap="$end_esc$end_noprint"

  # characters
  local space=" "
  local sep=""
  local alt_sep=""

  # basic colours
  local reset="${wrap}0${end_wrap}"
  local reset_bg="${wrap}49${end_wrap}"
  local bold="${wrap}1${end_wrap}"
  local reset_bold="${wrap}22${end_wrap}"

  # warn segment colours
  local warn_fg="${wrap}30${end_wrap}"
  local warn_bg="${wrap}41${end_wrap}"
  local warn_sep_fg="${wrap}31${end_wrap}"

  # host segment colours
  local host_fg="${wrap}30${end_wrap}"
  local host_bg="${wrap}45${end_wrap}"
  local host_sep_fg="${wrap}35${end_wrap}"

  # cwd segment colours
  local cwd_fg="${wrap}37${end_wrap}"

  # git segment colours
  local git_fg=""
  local git_clean_fg="${wrap}32${end_wrap}"
  local git_dirty_fg="${wrap}31${end_wrap}"

  PS1="$(__promptline_ps1)"
}

if [[ ! "$PROMPT_COMMAND" == *__promptline* ]]; then
  PROMPT_COMMAND='__promptline;'$'\n'"$PROMPT_COMMAND"
fi
